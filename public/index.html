<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mashuai&#39;s Notes</title>
  <meta name="author" content="mashuai">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Mashuai&#39;s Notes"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Mashuai&#39;s Notes" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Mashuai&#39;s Notes</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-12T04:07:49.000Z"><a href="/2015/11/12/使用Go开发HTTP中间件/">2015-11-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/12/使用Go开发HTTP中间件/">使用Go开发HTTP中间件</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://justinas.org/writing-http-middleware-in-go/" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。<br>&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。<br>&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库<code>net/http</code>中的函数<code>StripText</code>或者<code>TimeoutHandler</code>就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。<br>&emsp;&emsp; 我最近写的Go包<a href="https://github.com/justinas/nosurf" target="_blank" rel="external">nosurf</a>同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和<code>net/http</code>的接口无缝衔接。<br>&emsp;&emsp; 同样你还可以使用中间件做：</p>
<ul>
<li>隐藏长度防止缓冲攻击</li>
<li>速度限制</li>
<li>屏蔽爬虫</li>
<li>提供调试信息</li>
<li>添加HSTS，X-Frame-Options头</li>
<li>从错误中恢复</li>
<li>等等</li>
</ul>
<h3 id="编写一个简单的中间件">编写一个简单的中间件</h3><p>&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的<code>HOST</code>header实现。这样的中间件可以防止<a href="http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html" target="_blank" rel="external">主机欺骗攻击</a>。</p>
<h3 id="类型的机构">类型的机构</h3><p>&emsp;&emsp; 首先我们定义一个结构体，叫做<code>SingleHost</code></p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">SingleHost</span> struct <span class="container">&#123;</span><br><span class="line">    handler     http.<span class="type">Handler</span></span><br><span class="line">    allowedHost string</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 它只包含两个field。</p>
<ul>
<li>如果是一个可用的Host，那么我们会调用嵌入的handler。</li>
<li>allowedHost 就是允许的Host。<br>&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func NewSingleHost(<span class="operator"><span class="keyword">handler</span> <span class="keyword">http</span>.<span class="keyword">Handler</span>, allowedHost <span class="keyword">string</span>) *SingleHost &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SingleHost&#123;<span class="keyword">handler</span>: <span class="keyword">handler</span>, allowedHost: allowedHost&#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="请求处理">请求处理</h3><p>&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现<code>http.Handler</code>，我们只需要实现他的一个方法。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">type</span> <span class="type">Handler</span> interface <span class="container">&#123;</span><br><span class="line">        <span class="type">ServeHTTP</span>(<span class="type">ResponseWriter</span>, *<span class="type">Request</span>)</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 实现如下：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SingleHost)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> &#123;</span></span><br><span class="line">    host := r.Host</span><br><span class="line">    <span class="keyword">if</span> host == s.allowedHost &#123;</span><br><span class="line">        s.handler.ServeHTTP(w, r)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w.WriteHeader(<span class="number">403</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServeHTTP</code>只是检查请求的Host：</p>
<ul>
<li>如果Host和配置的allowed一直，那么调用handler的ServeHTTP。</li>
<li>如果不一直返回403<br>&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。<br>&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">singleHosted = <span class="function"><span class="title">NewSingleHost</span><span class="params">(myHandler, <span class="string">"example.com"</span>)</span></span></span><br><span class="line">http.<span class="function"><span class="title">ListenAndServe</span><span class="params">(<span class="string">":8080"</span>, singleHosted)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="另一种方式">另一种方式</h3><p>&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有<code>http.HandlerFunc</code>包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func SingleHost(<span class="operator"><span class="keyword">handler</span> <span class="keyword">http</span>.<span class="keyword">Handler</span>, allowedHost <span class="keyword">string</span>) <span class="keyword">http</span>.<span class="keyword">Handler</span> &#123;</span><br><span class="line">    ourFunc := func(w <span class="keyword">http</span>.ResponseWriter, r *<span class="keyword">http</span>.Request) &#123;</span><br><span class="line">        host := r.Host</span><br><span class="line">        <span class="keyword">if</span> host == allowedHost &#123;</span><br><span class="line">            <span class="keyword">handler</span>.ServeHTTP(w, r)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            w.WriteHeader(<span class="number">403</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">http</span>.HandlerFunc(ourFunc)</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 我们定义了一个简单的函数<code>SingleHost</code>，它包装了<code>Handler</code>和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。<br>&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。<br>&emsp;&emsp; 同时标准库同时使用了两种功能。<code>StripPrefix</code>使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。</p>
<h3 id="一个更复杂的例子">一个更复杂的例子</h3><p>&emsp;&emsp; 我们的<code>SingleHost</code>并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。</p>
<h3 id="添加数据是简单的">添加数据是简单的</h3><p>&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type AppendMiddleware struct &#123;</span><br><span class="line">    handler <span class="keyword">http</span>.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="operator">a</span> *AppendMiddleware) ServeHTTP(w <span class="keyword">http</span>.ResponseWriter, r *<span class="keyword">http</span>.Request) &#123;</span><br><span class="line">    <span class="operator">a</span>.handler.ServeHTTP(w, r)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"Middleware says hello."</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 返回的结构肯定会包含<code>Middleware says hello.</code></p>
<h3 id="问题">问题</h3><p>&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。<br>&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。<br>&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。<br>&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在<code>net/http/httptest</code>包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ModifierMiddleware struct &#123;</span><br><span class="line">    handler http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">m</span> *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    rec := httptest.NewRecorder()</span><br><span class="line">    <span class="comment">// passing a ResponseRecorder instead of the original RW</span></span><br><span class="line">    <span class="keyword">m</span>.handler.ServeHTTP(rec, r)</span><br><span class="line">    <span class="comment">// after this finishes, we have the response recorded</span></span><br><span class="line">    <span class="comment">// and can modify it before copying it to the original RW</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// we copy the original headers first</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> rec.Header() &#123;</span><br><span class="line">        w.Header()[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// and set an additional one</span></span><br><span class="line">    w.Header().<span class="keyword">Set</span>(<span class="string">"X-We-Modified-This"</span>, <span class="string">"Yup"</span>)</span><br><span class="line">    <span class="comment">// only then the status code, as this call writes out the headers </span></span><br><span class="line">    w.WriteHeader(418)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The body hasn't been written (to the real RW) yet,</span></span><br><span class="line">    <span class="comment">// so we can prepend some data.</span></span><br><span class="line">    data := []byte(<span class="string">"Middleware says hello again. "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// But the Content-Length might have been set already,</span></span><br><span class="line">    <span class="comment">// we should modify it by adding the length</span></span><br><span class="line">    <span class="comment">// of our own data.</span></span><br><span class="line">    <span class="comment">// Ignoring the error is fine here:</span></span><br><span class="line">    <span class="comment">// if Content-Length is empty or otherwise invalid,</span></span><br><span class="line">    <span class="comment">// Atoi() will return zero,</span></span><br><span class="line">    <span class="comment">// which is just what we'd want in that case.</span></span><br><span class="line">    clen, _ := strconv.Atoi(r.Header.<span class="literal">Get</span>(<span class="string">"Content-Length"</span>))</span><br><span class="line">    clen += len(data)</span><br><span class="line">    r.Header.<span class="keyword">Set</span>(<span class="string">"Content-Length"</span>, strconv.Itoa(clen))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finally, write out our data</span></span><br><span class="line">    w.Write(data)</span><br><span class="line">    <span class="comment">// then write out the original body</span></span><br><span class="line">    w.Write(rec.Body.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后僵尸我们中间件的输出：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="status">HTTP/1.1 <span class="number">418</span> I'm a teapot</span></span><br><span class="line"><span class="attribute">X-We-Modified-This</span>: <span class="string">Yup</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text/plain; charset=utf-8</span></span><br><span class="line"><span class="attribute">Content-Length</span>: <span class="string">37</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">Tue, 03 Sep 2013 18:41:39 GMT</span></span><br><span class="line"></span><br><span class="line"><span class="erlang-repl"><span class="variable">Middleware</span> <span class="function_or_atom">says</span> <span class="function_or_atom">hello</span> <span class="function_or_atom">again</span>. <span class="variable">Success</span><span class="exclamation_mark">!</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。</p>
<h3 id="和其他handler分享数据">和其他handler分享数据</h3><p>&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。<br>&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> csrfContext <span class="keyword">struct</span> &#123;</span><br><span class="line">    token <span class="typename">string</span></span><br><span class="line">    reason error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    contextMap = <span class="built_in">make</span>(<span class="keyword">map</span>[*http.Request]*csrfContext)</span><br><span class="line">    cmMutex    = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 数据由Token设置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">Token</span><span class="params">(req *http.Request)</span></span> string &#123;</span><br><span class="line">    cmMutex.<span class="type">RLock</span>()</span><br><span class="line">    <span class="keyword">defer</span> cmMutex.<span class="type">RUnlock</span>()</span><br><span class="line"></span><br><span class="line">    ctx, ok := contextMap[req]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx.token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;源码可以再nosurf的项目的<a href="https://github.com/justinas/nosurf/blob/master/context.go" target="_blank" rel="external">context.go</a>中找到。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-12T03:39:21.000Z"><a href="/2015/11/12/HTTP-2-和GO/">2015-11-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/12/HTTP-2-和GO/">HTTP/2 和GO</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://www.ianlewis.org/en/http2-and-go" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。<br>&emsp;&emsp; Brad Fitzpatrick实现了一个<a href="https://godoc.org/golang.org/x/net/http2" target="_blank" rel="external">golang.org/x/net/http2</a>的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。</p>
<h3 id="创建HTTP/2服务器">创建HTTP/2服务器</h3><p>&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用<code>http2.ConfigureServer()</code>来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/http2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">":8000"</span>, // Normally <span class="string">":443"</span></span><br><span class="line">        Handler: http.FileServer(http.Dir(cwd)),</span><br><span class="line">    &#125;</span><br><span class="line">    http2.ConfigureServer(srv, &amp;http2.Server&#123;&#125;)</span><br><span class="line">    log.Fatal(srv.ListenAndServeTLS(<span class="string">"server.crt"</span>, <span class="string">"server.key"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建HTTP/2_客户端">创建HTTP/2 客户端</h3><p>&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用<code>http2.Transport</code>对象，将他传给<code>http</code>包的client。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/http2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    client := http.Client&#123;</span><br><span class="line">        <span class="comment">// InsecureTLSDial is temporary and will likely be</span></span><br><span class="line">        <span class="comment">// replaced by a different API later.</span></span><br><span class="line">        Transport: &amp;http2.Transport&#123;InsecureTLSDial: true&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resp, <span class="keyword">err</span> := client.<span class="literal">Get</span>(<span class="string">"https://localhost:8000/"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        <span class="keyword">log</span>.Fatal(<span class="keyword">err</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, <span class="keyword">err</span> := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">        <span class="keyword">log</span>.Fatal(<span class="keyword">err</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="literal">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更多阅读">更多阅读</h3><p>&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考<a href="https://http2.github.io/" target="_blank" rel="external">HTTP/2 主页</a>，这个页面有很多其他资料的连接还有其他语言的实现。<br>&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么<a href="https://github.com/Jxck/http2" target="_blank" rel="external">Jxck’s http2 implementation</a>的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些<a href="https://github.com/Jxck/http2/blob/master/sample/http.go" target="_blank" rel="external">示例</a>。<br>&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-10T11:01:21.000Z"><a href="/2015/11/10/Go-Web-架构/">2015-11-10</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/10/Go-Web-架构/">Go Web 架构</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在<a href="https://www.refer-madness.com/" target="_blank" rel="external">Refer Madness</a>中使用了下面这个架构。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">public/</span><br><span class="line"></span>-<span class="ruby">views/</span><br><span class="line"></span>-<span class="ruby">models/</span><br><span class="line"></span>-<span class="ruby">utils/</span><br><span class="line"></span>-<span class="ruby">controllers/</span><br><span class="line"></span>-<span class="ruby">web/</span><br><span class="line"></span>-<span class="ruby">main.go</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着<code>utils</code>只能访问他自己和<code>models</code>，<code>web</code>只能访问它自己，<code>controllers</code>，<code>utils</code>，<code>models</code>。<code>models</code>只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。</p>
<h4 id="main-go">main.go</h4><p>&emsp;&emsp; <code>main.go</code>是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/utils"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/web"</span></span><br><span class="line">  <span class="string">"github.com/stretchr/graceful"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  isDevelopment := os.Getenv(<span class="string">"ENVIRONMENT"</span>) == <span class="string">"development"</span></span><br><span class="line">  dbURL := os.Getenv(<span class="string">"MONGOLAB_URI"</span>)</span><br><span class="line">  <span class="keyword">if</span> isDevelopment &#123;</span><br><span class="line">    dbURL = os.Getenv(<span class="string">"DB_PORT_27017_TCP_ADDR"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(<span class="string">"DATABASE_NAME"</span>), 0)</span><br><span class="line">  cuAccessor := utils.NewCurrentUserAccessor(1)</span><br><span class="line">  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(<span class="string">"GOOGLE_OAUTH2_CLIENT_ID"</span>),</span><br><span class="line">    os.Getenv(<span class="string">"GOOGLE_OAUTH2_CLIENT_SECRET"</span>), os.Getenv(<span class="string">"SESSION_SECRET"</span>),</span><br><span class="line">    isDevelopment, os.Getenv(<span class="string">"GOOGLE_ANALYTICS_KEY"</span>))</span><br><span class="line"></span><br><span class="line">  port := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line">  <span class="keyword">if</span> port == <span class="string">""</span> &#123;</span><br><span class="line">    port = <span class="string">"3000"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  graceful.Run(<span class="string">":"</span>+port, <span class="number">0</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 因为<code>main.go</code>实在最低的层级，所以它可以访问所有的目录：在这个例子里是<code>web</code>和<code>utils</code>。在这里获取了所有的环境变量并把它们注入到合适的地方。在<code>main.go</code>中创建了服务器，注入依赖，并且在配置的端口启动服务器。</p>
<h4 id="web">web</h4><p>&emsp;&emsp; <code>web</code>目录下是主要的服务代码，同时也包括了中间件代码。下面是<code>web</code>目录的内部结构：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-web/</span><br><span class="line"><span class="string">|-middleware/</span></span><br><span class="line"><span class="string">|-server.go</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; <code>server.go</code>包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/codegangsta/negroni"</span></span><br><span class="line">  <span class="string">"github.com/goincremental/negroni-sessions"</span></span><br><span class="line">  <span class="string">"github.com/goincremental/negroni-sessions/cookiestore"</span></span><br><span class="line">  <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/controllers"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/utils"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/web/middleware"</span></span><br><span class="line">  <span class="string">"github.com/unrolled/secure"</span></span><br><span class="line">  <span class="string">"gopkg.in/unrolled/render.v1"</span></span><br><span class="line">  <span class="string">"html/template"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  *negroni.Negroni</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,</span><br><span class="line">  sessionSecret <span class="typename">string</span>, isDevelopment <span class="typename">bool</span>, gaKey <span class="typename">string</span>) *Server &#123;</span><br><span class="line">  s := Server&#123;negroni.Classic()&#125;</span><br><span class="line">  session := utils.NewSessionManager()</span><br><span class="line">  basePage := utils.NewBasePageCreator(cua, gaKey)</span><br><span class="line">  renderer := render.New()</span><br><span class="line"></span><br><span class="line">  router := mux.NewRouter()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)</span><br><span class="line">  accountController.Register(router)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  s.Use(sessions.Sessions(<span class="string">"refermadness"</span>, cookiestore.New([]<span class="typename">byte</span>(sessionSecret))))</span><br><span class="line">  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())</span><br><span class="line">  s.UseHandler(router)</span><br><span class="line">  <span class="keyword">return</span> &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; <code>Server</code>结构体是一个<code>negroni.Negroni</code>的web server，在这个文件里有对<code>utils</code>和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/codegangsta/negroni"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/utils"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type <span class="type">Database</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  da utils.<span class="type">DatabaseAccessor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(da utils.DatabaseAccessor)</span></span> *<span class="type">Database</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;<span class="type">Database</span>&#123;da&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(d *Database)</span></span> <span class="type">Middleware</span>() negroni.<span class="type">HandlerFunc</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="func"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span></span> &#123;</span><br><span class="line">    reqSession := d.da.<span class="type">Clone</span>()</span><br><span class="line">    <span class="keyword">defer</span> reqSession.<span class="type">Close</span>()</span><br><span class="line">    d.da.<span class="type">Set</span>(r, reqSession)</span><br><span class="line">    next(rw, r)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从<a href="http://modocache.svbtle.com/restful-go" target="_blank" rel="external">Brian Gesiak’s blog post on RESTful Go</a>中得到，将其修改为适合我的文件。</p>
<h4 id="controllers/">controllers/</h4><p>&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package controllers</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"errors"</span></span><br><span class="line">  <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/models"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/utils"</span></span><br><span class="line">  <span class="string">"gopkg.in/mgo.v2/bson"</span></span><br><span class="line">  <span class="string">"gopkg.in/unrolled/render.v1"</span></span><br><span class="line">  <span class="string">"html/template"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceControllerImpl struct &#123;</span><br><span class="line">  currentUser utils.CurrentUserAccessor</span><br><span class="line">  basePage    utils.BasePageCreator</span><br><span class="line">  renderer    *render.Render</span><br><span class="line">  database    utils.DatabaseAccessor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,</span><br><span class="line">  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;ServiceControllerImpl&#123;</span><br><span class="line">    currentUser: currentUser,</span><br><span class="line">    basePage:    basePage,</span><br><span class="line">    renderer:    renderer,</span><br><span class="line">    database:    database,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">sc</span> *ServiceControllerImpl) Register(router *mux.Router) &#123;</span><br><span class="line">  router.HandleFunc(<span class="string">"/service/&#123;id&#125;"</span>, <span class="keyword">sc</span>.single)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serviceResult struct &#123;</span><br><span class="line"><span class="comment">  *models.Service</span></span><br><span class="line">  RandomCode *models.ReferralCode</span><br><span class="line">  UserCode   *models.ReferralCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> servicePage struct &#123;</span><br><span class="line">  utils.BasePage</span><br><span class="line">  ResultString <span class="literal">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="keyword">sc</span> *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">  data, <span class="keyword">err</span> := <span class="keyword">sc</span>.<span class="literal">get</span>(w, r)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> len(r.Header[<span class="string">"Content-Type"</span>]) == 1 &amp;&amp; strings.Contains(r.Header[<span class="string">"Content-Type"</span>][0], <span class="string">"application/json"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">      <span class="keyword">sc</span>.renderer.JSON(w, http.StatusBadRequest, map[string]string&#123;</span><br><span class="line">        <span class="string">"error"</span>: <span class="keyword">err</span>.<span class="keyword">Error</span>(),</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="literal">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">sc</span>.renderer.JSON(w, http.StatusOK, data)</span><br><span class="line">    <span class="literal">return</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">    http.<span class="keyword">Error</span>(w, <span class="keyword">err</span>.<span class="keyword">Error</span>(), http.StatusBadRequest)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resultString, _ := json.Marshal(data)</span><br><span class="line">  t, _ := template.ParseFiles(<span class="string">"views/layout.html"</span>, <span class="string">"views/service.html"</span>)</span><br><span class="line">  t.Execute(w, servicePage&#123;<span class="keyword">sc</span>.basePage.<span class="literal">Get</span>(r), <span class="literal">string</span>(resultString)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="utils/">utils/</h4><p>&emsp;&emsp; 在<code>utils</code>目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/gorilla/context"</span></span><br><span class="line">  <span class="string">"github.com/larryprice/refermadness/models"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type <span class="type">CurrentUserAccessor</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  key int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">NewCurrentUserAccessor</span><span class="params">(key int)</span></span> *<span class="type">CurrentUserAccessor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;<span class="type">CurrentUserAccessor</span>&#123;key&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(cua *CurrentUserAccessor)</span></span> <span class="type">Set</span>(r *http.<span class="type">Request</span>, user *models.<span class="type">User</span>) &#123;</span><br><span class="line">  context.<span class="type">Set</span>(r, cua.key, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(cua *CurrentUserAccessor)</span></span> <span class="type">Clear</span>(r *http.<span class="type">Request</span>) &#123;</span><br><span class="line">  context.<span class="type">Delete</span>(r, cua.key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(cua *CurrentUserAccessor)</span></span> <span class="type">Get</span>(r *http.<span class="type">Request</span>) *models.<span class="type">User</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> rv := context.<span class="type">Get</span>(r, cua.key); rv != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rv.(*models.<span class="type">User</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="models/">models/</h4><p>&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package models</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  <span class="string">"gopkg.in/mgo.v2"</span></span><br><span class="line">  <span class="string">"gopkg.in/mgo.v2/bson"</span></span><br><span class="line">  <span class="string">"strings"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Service struct &#123;</span><br><span class="line">  // identification information</span><br><span class="line">  ID          bson.ObjectId `bson:<span class="string">"_id"</span>`</span><br><span class="line">  Name        <span class="built_in">string</span>        `bson:<span class="string">"name"</span>`</span><br><span class="line">  Description <span class="built_in">string</span>        `bson:<span class="string">"description"</span>`</span><br><span class="line">  URL         <span class="built_in">string</span>        `bson:<span class="string">"url"</span>`</span><br><span class="line">  Search      <span class="built_in">string</span>        `bson:<span class="string">"search"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(name, description, url string, creatorID bson.ObjectId)</span> *<span class="title">Service</span> &#123;</span></span><br><span class="line">  url = strings.TrimPrefix(strings.TrimPrefix(url, <span class="string">"http://"</span>), <span class="string">"https://"</span>)</span><br><span class="line">  <span class="keyword">return</span> &amp;Service&#123;</span><br><span class="line">    ID:            bson.NewObjectId(),</span><br><span class="line">    Name:          name,</span><br><span class="line">    URL:           url,</span><br><span class="line">    Description:   description,</span><br><span class="line">    Search:        strings.ToLower(name) + <span class="string">";"</span> + strings.ToLower(description) + <span class="string">";"</span> + strings.ToLower(url),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">Save</span><span class="params">(db *mgo.Database)</span> <span class="title">error</span> &#123;</span></span><br><span class="line">  _, err := s.coll(db).UpsertId(s.ID, s)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Service)</span> <span class="title">FindByID</span><span class="params">(id bson.ObjectId, db *mgo.Database)</span> <span class="title">error</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> s.coll(db).FindId(id).One(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Service)</span> <span class="title">coll</span><span class="params">(db *mgo.Database)</span> *<span class="title">mgo</span>.<span class="title">Collection</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> db.C(<span class="string">"service"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Services []Service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Services)</span> <span class="title">FindByIDs</span><span class="params">(ids []bson.ObjectId, db *mgo.Database)</span> <span class="title">error</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> s.coll(db).Find(bson.M&#123;<span class="string">"_id"</span>: bson.M&#123;<span class="string">"$in"</span>: ids&#125;&#125;).Sort(<span class="string">"name"</span>).All(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Services)</span> <span class="title">coll</span><span class="params">(db *mgo.Database)</span> *<span class="title">mgo</span>.<span class="title">Collection</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> db.C(<span class="string">"service"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="views/">views/</h4><p>&emsp;&emsp; 将Golang的模板文件放到<code>views</code>目录下。这样，不管用什么样的模板引擎都可以直接放到<code>views</code>下。</p>
<h4 id="public/">public/</h4><p>&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如<code>css</code>,<code>img</code>,<code>scripts</code>。</p>
<h4 id="如何运行">如何运行</h4><p>&emsp;&emsp; 毫无疑问，我最喜欢的就是<a href="https://www.docker.com/" target="_blank" rel="external">docker</a>，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到<code>$GOPATH/src/github.com/larryprice/refermadness</code>,运行<code>go get</code>来获取所有的依赖，然后运行 <code>go run main.go</code>或者<code>go build; ./refermadness</code>运行程序。如果你也喜欢使用docker，那么可以直接通过<code>Dockerfile</code>来运行。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> golang:<span class="number">1.4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">go get github.com/codegangsta/gin</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">ADD</span> <span class="bash">. /go/src/github.com/larryprice/refermadness</span><br><span class="line"></span><span class="built_in">WORKDIR</span> <span class="bash">/go/src/github.com/larryprice/refermadness</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">go get</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 同时我也很喜欢<a href="https://github.com/docker/compose" target="_blank" rel="external">compose</a>，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的<code>docker-compose.yml</code>文件。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">main:</span></span><br><span class="line"><span class="label">  build:</span> .</span><br><span class="line"><span class="label">  command:</span> gin run</span><br><span class="line"><span class="label">  env_file:</span> .env</span><br><span class="line"><span class="label">  volumes:</span></span><br><span class="line">    - .<span class="regexp">/:/</span>go<span class="regexp">/src/</span>github.com<span class="regexp">/larryprice/</span>refermadness</span><br><span class="line"><span class="label">  working_dir:</span> <span class="regexp">/go/</span>src<span class="regexp">/github.com/</span>larryprice/refermadness</span><br><span class="line"><span class="label">  ports:</span></span><br><span class="line">    - <span class="string">"3000:3000"</span></span><br><span class="line"><span class="label">  links:</span></span><br><span class="line">    - db</span><br><span class="line"><span class="string">sass:</span></span><br><span class="line"><span class="label">  image:</span> larryprice/sass</span><br><span class="line"><span class="label">  volumes:</span></span><br><span class="line">    - .<span class="regexp">/public/</span><span class="string">css:</span>/src</span><br><span class="line"><span class="string">jsx:</span></span><br><span class="line"><span class="label">  image:</span> larryprice/jsx</span><br><span class="line"><span class="label">  volumes:</span></span><br><span class="line">    - .<span class="regexp">/public/</span><span class="string">scripts:</span>/src</span><br><span class="line"><span class="string">db:</span></span><br><span class="line"><span class="label">  image:</span> <span class="string">mongo:</span><span class="number">3.0</span></span><br><span class="line"><span class="label">  command:</span> mongod --smallfiles --quiet --logpath=<span class="regexp">/dev/</span><span class="literal">null</span></span><br><span class="line"><span class="label">  volumes_from:</span></span><br><span class="line">    - dbvolume</span><br><span class="line"><span class="string">dbvolume:</span></span><br><span class="line"><span class="label">  image:</span> <span class="string">busybox:</span>ubuntu-<span class="number">14.04</span></span><br><span class="line"><span class="label">  volumes:</span></span><br><span class="line">    - <span class="regexp">/data/</span>db</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 然后运行<code>docker-compose up</code>来运行所有的容器并启动服务器。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-09T10:26:35.000Z"><a href="/2015/11/09/Ansible-入门指南/">2015-11-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/09/Ansible-入门指南/">Ansible 入门指南</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="http://docs.ansible.com/ansible/intro_getting_started.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="快速入门">快速入门</h2><h3 id="前言">前言</h3><p>&emsp;&emsp; 现在你已经知道如何<a href="http://docs.ansible.com/ansible/intro_installation.html" target="_blank" rel="external">安装</a>Ansible了，现在可以深入并开始使用Ansible的一些命令了。<br>&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。<br>&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读<a href="http://docs.ansible.com/ansible/intro_adhoc.html" target="_blank" rel="external">特别命令简介</a>来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。</p>
<h3 id="远程连接信息">远程连接信息</h3><p>&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。<br>&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。<a href="http://docs.ansible.com/ansible/playbooks_acceleration.html" target="_blank" rel="external">加速功能</a>。<br>&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。<br>&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在<a href="http://docs.ansible.com/ansible/intro_configuration.html" target="_blank" rel="external">配置文件</a>中切换到SCP模式。<br>&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数<code>--ask-pass</code>。如果需要使用sudo权限，那么也要提供<code>--ask-sudo-pass</code>参数。<br>&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。<br>&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。</p>
<h3 id="第一个命令">第一个命令</h3><p>&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。<br>&emsp;&emsp; 编辑（或者创建）<code>/etc/ansible/hosts</code>文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的<code>authorized_keys</code>文件中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192<span class="class">.168</span><span class="class">.1</span><span class="class">.50</span></span><br><span class="line"><span class="tag">aserver</span><span class="class">.example</span><span class="class">.org</span></span><br><span class="line"><span class="tag">bserver</span><span class="class">.example</span><span class="class">.org</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这是一个清单文件，同样会再<a href="http://docs.ansible.com/ansible/intro_inventory.html" target="_blank" rel="external">主机清单</a>中介绍。<br>&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">ssh</span>-agent <span class="keyword">bash</span><br><span class="line"></span><span class="label">ssh</span>-<span class="keyword">add </span>~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>(根据你的设置，你可能需要使用<code>--private-key</code>选项来制定一个pem文件)<br>&emsp;&emsp; 现在可以ping一下所有的主机了。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ansible</span> <span class="literal">all</span> -m ping</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上<code>-u</code>的选项。<br>&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上<code>--sudo</code>选项。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">as</span> bruce</span><br><span class="line">$ ansible all -<span class="keyword">m</span> ping -<span class="keyword">u</span> bruce</span><br><span class="line"># <span class="keyword">as</span> bruce sudoing to root</span><br><span class="line">$ ansible all -<span class="keyword">m</span> ping -<span class="keyword">u</span> bruce --sudo</span><br><span class="line"># <span class="keyword">as</span> bruce, sudoing to batman</span><br><span class="line">$ ansible all -<span class="keyword">m</span> ping -<span class="keyword">u</span> bruce --sudo --sudo-user batman</span><br><span class="line"></span><br><span class="line"># With latest <span class="keyword">version</span> of ansible `sudo` is deprecated <span class="keyword">so</span> <span class="keyword">use</span> become</span><br><span class="line"># <span class="keyword">as</span> bruce, sudoing to root</span><br><span class="line">$ ansible all -<span class="keyword">m</span> ping -<span class="keyword">u</span> bruce -b</span><br><span class="line"># <span class="keyword">as</span> bruce, sudoing to batman</span><br><span class="line">$ ansible all -<span class="keyword">m</span> ping -<span class="keyword">u</span> bruce -b --become-user batman</span><br></pre></td></tr></table></figure>
<p>(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)</p>
<p>&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ansible all -<span class="tag">a</span> <span class="string">"/bin/echo hello"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读<a href="http://docs.ansible.com/ansible/intro_adhoc.html" target="_blank" rel="external">更多命令介绍</a>来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible <a href="http://docs.ansible.com/ansible/playbooks.html" target="_blank" rel="external">Playbooks</a>的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。</p>
<h3 id="主机密钥检查">主机密钥检查</h3><p>&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。<br>&emsp;&emsp; 如果远程主机成新安装并且在<code>know_hosts</code>下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在<code>know_hosts</code>文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。<br>&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改<code>/etc/ansible/ansible.cfg</code>或者是<code>~/.ansible.cfg</code>来关闭这个功能。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[default]</span></span><br><span class="line"><span class="setting">host_key_checking = <span class="value"><span class="keyword">False</span></span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 同样也可以通过环境变量来修改。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">export</span> ANSIBLE_HOST_KEY_CHECKING=<span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。<br>&emsp;&emsp; 除非Ansible的任务被标记为”no_log:True”，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。<br>&emsp;&emsp; 如果要再本机开启log可以查看<a href="http://docs.ansible.com/ansible/intro_configuration.html" target="_blank" rel="external">配置章节</a>来设置“log_path”开启。企业用户可能会对<a href="http://docs.ansible.com/ansible/tower.html" target="_blank" rel="external">Ansible Tower</a>。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-07T16:39:10.000Z"><a href="/2015/11/08/Vagrant-Ansible-快速入门教程/">2015-11-08</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/08/Vagrant-Ansible-快速入门教程/">Vagrant &amp; Ansible 快速入门教程</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html" target="_blank" rel="external">原文地址</a>  </p>
<p>&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于<a href="https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html" target="_blank" rel="external">Chef</a>的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。<br>&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  </p>
<h2 id="为什么使用Ansible">为什么使用Ansible</h2><p>&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。<br>&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。</p>
<h2 id="Ansible_和_Vagrant">Ansible 和 Vagrant</h2><p>&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。</p>
<h2 id="基础">基础</h2><p>&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~<span class="regexp">/Projects/vagrant</span>-ansible</span><br><span class="line">cd ~<span class="regexp">/Projects/vagrant</span>-ansible</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vagrant</span> init ubuntu/trusty64</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫<code>Vagrantfile</code>的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：</p>
<figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VAGRANTFILE_API_VERSION = <span class="variable">"2"</span></span><br><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.box = <span class="variable">"ubuntu/trusty64"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到<code>end</code>之前。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config<span class="class">.vm</span><span class="class">.network</span> <span class="string">"forworded_port"</span>, guest: <span class="number">80</span>, host:<span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到<code>Vagrantfile</code>的<code>end</code>之前。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision <span class="symbol">:ansible</span> <span class="keyword">do</span> |ansible|</span><br><span class="line">  ansible.playbook = <span class="string">"playbook.yml"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 以上所有的任务完成之后你的<code>Vagrantfile</code>将会是一下的配置。  </p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">VAGRANTFILE_API_VERSION </span>= <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="constant">Vagrant.</span>configure(<span class="constant">VAGRANTFILE_API_VERSION)</span> <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.box = <span class="string">"ubuntu/trusty64"</span></span><br><span class="line"></span><br><span class="line">  config.vm.network <span class="string">"forwarded_port"</span>, <span class="symbol">guest:</span> <span class="number">80</span>, <span class="symbol">host:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="symbol">:ansible</span> <span class="keyword">do</span> |ansible|</span><br><span class="line">    ansible.playbook = <span class="string">"playbook.yml"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="基本术语">基本术语</h2><p>&emsp;&emsp; Ansible再你的服务器上运行一系列的<em>Tasks</em>。把Task想象成一个单一的Bash命令。接着是<em>playbook</em>，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的<em>Module</em>，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  </p>
<h2 id="第一个Playbook">第一个Playbook</h2><p>&emsp;&emsp; 创建一个叫<code>playbook.yml</code>的文件，这个名字必须和<code>Vagrantfile</code>的<code>ansible.playbook</code>相同。<br>&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。<br>&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到<code>playbook.yml</code>文件中。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">--</span><br><span class="line"></span>-<span class="ruby"> <span class="symbol">host:</span> all</span><br><span class="line"></span>  sudo: true</span><br><span class="line">  tasks:</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值<code>all</code>，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 <code>tasks:</code> 用来添加Task。</p>
<p>&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  </p>
<ol>
<li>更新 Apt Cache</li>
<li>安装 Apache</li>
<li>安装 MySQL</li>
<li>安装 PHP</li>
</ol>
<p>&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。<br>&emsp;&emsp; 首先我们给每一个task一个<code>name:</code>，这个可以是任何描述，它用来描述这个任务，如下:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="property">name</span>: this should be <span class="keyword">some</span> descriptive <span class="type">text</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 紧随其后的是一些<code>key=value</code>的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。</p>
<p>&emsp;&emsp; 安装Apache的任务如下：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- name: install apache</span><br><span class="line">  apt: name=apache2 <span class="keyword">state</span>=present</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到<code>playbook.yml</code>中，最后代码如下：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: <span class="literal">all</span></span><br><span class="line">  sudo: true</span><br><span class="line">  tasks:</span><br><span class="line">    - name: update apt cache</span><br><span class="line">      apt: update_cache=yes</span><br><span class="line">    - name: install apache</span><br><span class="line">      apt: name=apache2 <span class="keyword">state</span>=present</span><br><span class="line">    - name: install mysql</span><br><span class="line">      apt: name=mysql-server <span class="keyword">state</span>=present</span><br><span class="line">    - name: install php</span><br><span class="line">      apt: name=php5 <span class="keyword">state</span>=present</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 现在我们已经配置完了，然后运行<code>vagrant up</code>，你将会看到如下图所示：<br><img src="https://adamcod.es/img/posts/vagrant-ansible-lamp.gif" alt="result">  </p>
<p>&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将<code>info.php</code>文件添加到<code>/var/www/html</code>下。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="preprocessor">&lt;?php</span> phpinfo();<span class="preprocessor">?&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 然后在本机浏览器打开<a href="http://localhost:8080/info.php" target="_blank" rel="external">http://localhost:8080/info.php</a>，就会看到你想要看到的。</p>
<p><strong>翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习</strong></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-06T08:49:47.000Z"><a href="/2015/11/06/Vagrant-入门指南/">2015-11-06</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/06/Vagrant-入门指南/">Vagrant 入门指南</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://docs.vagrantup.com/v2/getting-started/index.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="开始">开始</h2><p>&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。<br>&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下<a href="https://docs.vagrantup.com/v2/why-vagrant/" target="_blank" rel="external">Why Vagrant</a>。<br>&emsp;&emsp;这篇入门指南将会基于<a href="https://www.virtualbox.org/" target="_blank" rel="external">VirtualBox</a>来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的<a href="https://docs.vagrantup.com/v2/getting-started/providers.html" target="_blank" rel="external">提供商</a></p>
<blockquote>
<p>更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O’Reilly 出版的<a href="http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449335837&amp;linkCode=as2&amp;tag=vagrant-20" target="_blank" rel="external">Vagrant: Up and Running</a> 更感兴趣，</p>
</blockquote>
<h2 id="启动运行">启动运行</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vagrant init hashicorp/precise32</span><br><span class="line"><span class="variable">$ </span>vagrant up</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在<a href="https://www.virtualbox.org/" target="_blank" rel="external">VirtualBox</a>虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过<code>vagrant ssh</code> 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用<code>vagrant destory</code>来删除所有的痕迹。<br>&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。<br>&emsp;&emsp;通过使用Vagrant,对于任何项目来说<code>vagrant up</code> 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。<br>&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  </p>
<h2 id="项目配置">项目配置</h2><p>&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个<a href="https://docs.vagrantup.com/v2/vagrantfile/" target="_blank" rel="external">Vagrantfile</a>。该文件的作用有两个:  </p>
<ol>
<li>指定项目的根目录。很多Vagrant的配置跟这个目录有关。  </li>
<li>描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  </li>
</ol>
<p>&emsp;&emsp; Vagrant 有一个内建的命令<code>vagrant init</code>用来初始化项目。出于本指南的目的，请在终端输入一下命令  </p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir vagrant_getting_started</span><br><span class="line"><span class="variable">$ </span>cd vagrant_getting_started</span><br><span class="line"><span class="variable">$ </span>vagrant init</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 以上命令将在你的当前目录下创建<code>Vagrantfile</code>。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。<br>&emsp;&emsp; 同样也可以在一个已存在的目录下运行<code>vagrant init</code>，来未一个已有项目设置Vagrant环境。<br>&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。</p>
<h2 id="Boxes">Boxes</h2><p>&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  </p>
<h3 id="安装box">安装box</h3><p>&emsp;&emsp; 如果你运行了<a href="https://docs.vagrantup.com/v2/getting-started/" target="_blank" rel="external">开始指南</a>的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。<br>&emsp;&emsp; Boxes 由Vagrant的<code>vagrant box add</code>命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  </p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant <span class="keyword">box </span><span class="keyword">add </span>hashicorp/precise32</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这个将从<a href="https://atlas.hashicorp.com/boxes/search" target="_blank" rel="external">HashiCorp’s Atlas box catalog</a>下载一个名字为<code>hashicorp/precise32</code>的box。你可以从HashiCorp’s Atlas box catalog中找到各种box。很容易从HashiCorp’s Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。<br>&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的<code>hashicorp/precise32</code>的box，其中一个主机添加文件并不会影响另一个主机。  </p>
<h3 id="使用box">使用box</h3><p>&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:</p>
<figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="variable">"2"</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.box = <span class="variable">"hashicorp/precise32"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 在这个例子中，”hashicorp/precise32” 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。<br>&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  </p>
<h3 id="寻找更多box">寻找更多box</h3><p>&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的”hashicorp/precise32”的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。<br>&emsp;&emsp; 寻找更多box的最好的地方是<a href="https://atlas.hashicorp.com/boxes/search" target="_blank" rel="external">HashiCorp’s Atlas box catalog</a>。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。<br>&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。<br>&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  </p>
<h2 id="启动并且SSH登陆">启动并且SSH登陆</h2><p>&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vagrant</span> up</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vagrant</span> ssh</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心<code>rm -rf /</code> 这种命令，因为Vagrant的<code>/vagrant</code>目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。<br>&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。<br>&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用<code>vagrant destory</code>来清除你再虚拟机的痕迹。</p>
<h2 id="同步文件夹">同步文件夹</h2><p>&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用<em>同步文件夹</em>Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。<br>&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的<code>/vagrant</code>的。再次运行<code>vagrant up</code> 并且ssh到虚拟机。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vagrant up</span><br><span class="line">...</span><br><span class="line"><span class="variable">$ </span>vagrant ssh</span><br><span class="line">...</span><br><span class="line">vagrant<span class="variable">@precise32</span><span class="symbol">:~</span><span class="variable">$ </span>ls /vagrant</span><br><span class="line"><span class="constant">Vagrantfile</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vagrant<span class="variable">@precise32</span><span class="symbol">:~</span><span class="variable">$ </span>touch /vagrant/foo</span><br><span class="line">vagrant<span class="variable">@precise32</span><span class="symbol">:~</span><span class="variable">$ </span>exit</span><br><span class="line"><span class="variable">$ </span>ls</span><br><span class="line">foo <span class="constant">Vagrantfile</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 哇！<code>foo</code>已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。<br>&emsp;&emsp; 通过使用<a href="https://docs.vagrantup.com/v2/synced-folders/" target="_blank" rel="external">同步文件夹</a>，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。</p>
<h2 id="配置">配置</h2><p>&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。<br>&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你<code>vagrant up</code>的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  </p>
<h3 id="安装Apache">安装Apache</h3><p>&emsp;&emsp; 对于我们的项目来说可以仅仅使用<a href="http://httpd.apache.org/" target="_blank" rel="external">Apache</a>，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为<code>bootstrap.sh</code>的文件。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/bin/env bash</span><br><span class="line"></span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y apache2</span><br><span class="line"><span class="keyword">if</span> ! [ -L /var/www ]; <span class="keyword">then</span></span><br><span class="line">  rm -rf /var/www</span><br><span class="line">  ln -fs /vagrant /var/www</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Vagrant.</span>configure(<span class="string">"2"</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.box = <span class="string">"hashicorp/precise32"</span></span><br><span class="line">  config.vm.provision <span class="symbol">:shell</span>, <span class="symbol">path:</span> <span class="string">"bootstrap.sh"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用<code>shell</code>配置器运行<code>bootstrap.sh</code>脚本启动机器。脚本的路径是项目更目录的相对路径。</p>
<h3 id="配置-1">配置</h3><p>&emsp;&emsp; 在所有的事情都配置好好，运行<code>vagrant up</code>来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行<code>vagrant reload --provision</code>, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。<code>--provision</code>表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。<br>&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vagrant ssh</span><br><span class="line">...</span><br><span class="line">vagrant<span class="variable">@precise32</span><span class="symbol">:~</span><span class="variable">$ </span>wget -qO- <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的<code>DocumentRoot</code>指向了<code>/vagrant</code>。<br>&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。</p>
<h2 id="网络">网络</h2><p>&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。</p>
<h3 id="端口转发">端口转发</h3><p>&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。<br>&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) do |config|</span><br><span class="line">  config.vm.box = <span class="string">"hashicorp/precise32"</span></span><br><span class="line">  config.vm.<span class="string">provision :</span>shell, <span class="string">path:</span> <span class="string">"bootstrap.sh"</span></span><br><span class="line">  config.vm.<span class="string">network :</span>forwarded_port, <span class="string">guest:</span> <span class="number">80</span>, <span class="string">host:</span> <span class="number">4567</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 运行<code>vagrant reload</code>，或者如果没有启动过虚拟机运行<code>vagrant up</code>。使配置生效。</p>
<h3 id="其他的网络配置">其他的网络配置</h3><p>&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读<a href="https://docs.vagrantup.com/v2/networking/" target="_blank" rel="external">networking</a>章节。</p>
<h2 id="共享">共享</h2><p>&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做<a href="https://docs.vagrantup.com/v2/share/" target="_blank" rel="external">Vagrant Share</a>。<br>&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。</p>
<h3 id="登录Harshicorp’s_Altas">登录Harshicorp’s Altas</h3><p>&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个<a href="https://atlas.hashicorp.com/" target="_blank" rel="external">HashiCorp’s Altas</a>的账号。不必担心，它是免费的。<br>&emsp;&emsp; 当你有了账号后，你就可以使用<code>vagrant login</code>来登陆</p>
<figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant login</span><br><span class="line">Username <span class="keyword">or</span> Email: mitchellh</span><br><span class="line">Password (will <span class="keyword">be</span> hidden):</span><br><span class="line">You're <span class="keyword">now</span> logged <span class="keyword">in</span>!</span><br></pre></td></tr></table></figure>
<h3 id="共享-1">共享</h3><p>&emsp;&emsp; 当你登录之后，你就可以使用<code>vagrant share</code>来共享环境了。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant share</span><br><span class="line">...</span><br><span class="line">=<span class="ruby"><span class="status">=&gt;</span> <span class="symbol">default:</span> <span class="constant">Your</span> <span class="constant">Vagrant</span> <span class="constant">Share</span> is running!</span><br><span class="line"></span>=<span class="ruby"><span class="status">=&gt;</span> <span class="symbol">default:</span> <span class="constant">URL</span><span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/frosty-weasel-0857.vagrantshare.com</span><br><span class="line"></span></span>...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面<code>vagrant share</code>生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。<br>&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。<br>&emsp;&emsp; 关闭共享只需要使用<code>Ctrl+C</code>即可，重新刷新URL，你会发现你的环境已经不再被共享了。<br>&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的<a href="https://docs.vagrantup.com/v2/share/" target="_blank" rel="external">Vagrant Share</a>文档。</p>
<h2 id="关闭">关闭</h2><p>&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。<br>&emsp;&emsp; 通过Vagrant，我们可以<em>suspend</em>,<em>halt</em>或者<em>destory</em>虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  </p>
<ul>
<li><strong>suspend</strong> 使用<code>vagrant suspend</code>命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用<code>vagrant up</code>命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  </li>
<li><strong>halting</strong> 使用<code>vagrant halt</code>命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行<code>vagrant up</code>命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。</li>
<li><strong>destory</strong> 使用<code>vagrant destory</code>命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用<code>vagrant up</code>的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是<code>vagrant up</code>将会从头开始，这样会花费更长的时间。</li>
</ul>
<h2 id="重新构建">重新构建</h2><p>&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过<code>vagrant up</code>来轻松运行他。<br>&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行<code>vagrant up</code>即可重新创建相同的环境。</p>
<h3 id="Provider">Provider</h3><p>&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持<a href="https://www.virtualbox.org/" target="_blank" rel="external">VirtualBox</a>。但是Vagrant可以与多个后端Provider一起使用，例如<a href="https://docs.vagrantup.com/v2/vmware/" target="_blank" rel="external">VMware</a>,<a href="http://github.com/mitchellh/vagrant-aws" target="_blank" rel="external">AWS</a>等。继续阅读来了解如何它们的更多信息以及如何使用它们。<br>&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up <span class="comment">--provider=vmware_fusion</span></span><br></pre></td></tr></table></figure>
<p>准备转移到云端了？使用AWS：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant up <span class="comment">--provider=aws</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 当你使用其他Provider运行<code>vagrant up</code>的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：<code>vagrant destory</code>，无需额外的参数。<br>&emsp;&emsp; 更多信息请参考<a href="https://docs.vagrantup.com/v2/providers/" target="_blank" rel="external">provider</a>。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:mashuai.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Ansible/">Ansible</a><small>2</small></li>
  
    <li><a href="/tags/Architecture/">Architecture</a><small>1</small></li>
  
    <li><a href="/tags/Go/">Go</a><small>3</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>1</small></li>
  
    <li><a href="/tags/HTTP-2/">HTTP/2</a><small>1</small></li>
  
    <li><a href="/tags/Middleware/">Middleware</a><small>1</small></li>
  
    <li><a href="/tags/Translate/">Translate</a><small>5</small></li>
  
    <li><a href="/tags/Vagrant/">Vagrant</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 mashuai
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'jabfor';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48348924-2', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>